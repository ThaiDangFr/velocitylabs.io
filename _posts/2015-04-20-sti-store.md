---
author:
  name: Dave Tapley
  twitter: davetapley
  gplus:
  bio: Programmer
  image:
excerpt:
  You have an STI model, and you need to add attributes which only exist for certain sub-classes.
layout: post
published: true
tags:
- postgresql
- sti
title: "STI store: Putting attributes in their place"
---


### The problem

You have a model which uses [single table inheritance](http://www.martinfowler.com/eaaCatalog/singleTableInheritance.html), and you need to add an attribute which exists for some sub-classes, but not others.

Firstly, it's worth noting that [using polymorphic associations](http://railscasts.com/episodes/394-sti-and-polymorphic-associations) may be a better fit for your use case, but if you're sticking with STI, read on. For the remainder of the post, we'll implement [Martin Fowlers's example class hierarchy](http://railscasts.com/episodes/394-sti-and-polymorphic-associations). We've already [created the player model](https://github.com/velocity-labs/sti_store/commit/417494bbb71f02d426b4a233251594b9e3a22aaa) and [added sub-classes with STI](https://github.com/velocity-labs/sti_store/commit/8f68b2edf0f3cbea0651ef624b21cda61d28fc51).

### The 'extra column' solution

We'd like to add batting average, but only for the `Cricketer` model.
Normally in this situation, we're stuck [adding the column to the player model](https://github.com/velocity-labs/sti_store/commit/f992c5eb780b6cb3d41b7108fa3bccc125961800#diff-5592067a96f83276b35ae4ab53ae3ad8).

This has a few disadvantages:

1. Both the `Player` and `Footballer` models will respond to the `batting_average` methods. I guess we'll have to [skip those tests](https://github.com/velocity-labs/sti_store/commit/f992c5eb780b6cb3d41b7108fa3bccc125961800#diff-897e0fb627673887f6f69a589c98f5e5).

1. Whenever we have a non-cricketer, they'll always have a null `batting_average`:

        sti_store_development=# SELECT name, type, batting_average FROM players;
         name  |    type    | batting_average
        -------+------------+-----------------
         Alice | Footballer |
         Bob   | Cricketer  |            61.2
        (2 rows)

      This isn't so bad for one column, but following on with the example and [adding bowler model](https://github.com/velocity-labs/sti_store/commit/97b7a5c9eb086807b2b6ad72ee5daadd4027320b) it's easy to see how this can become compounded we add additional sub-classes with their own attributes:

        sti_store_development=# SELECT name, type, batting_average, bowling_average FROM players;
         name  | type       | batting_average | bowling_average
        -------+------------+-----------------+-----------------
         Alice | Footballer |                 |
         Bob   | Cricketer  |            61.2 |
         Carol | Bowler     |            12.3 |            80.3
         (3 rows)

### The 'STI store' solution

Disclaimer: We use PostgreSQL's JSON type here, but this is not required, see errata below.

Instead of adding a separate column for each sub-class specific attribute, we'll [add a single column](https://github.com/velocity-labs/sti_store/commit/cfe3e3c37c3ab981178659a5cf5612f5a0a5d3d3#diff-dda83829809ad6207fd35779aa135900) called `sti_store`, with type `json`. Now we can use the lesser known `store_accessor` method from [`ActiveRecord::Store`](http://api.rubyonrails.org/classes/ActiveRecord/Store.html) to generate accessor methods for `batting_average`.
Crucially, we can [specify this on the cricketer subclass](https://github.com/velocity-labs/sti_store/commit/cfe3e3c37c3ab981178659a5cf5612f5a0a5d3d3#diff-7ea4f93e4563e67948dd8d929aeb40f1).

By doing this we have a solution to the first issue given above: The `Cricketer` model [responds to](https://github.com/velocity-labs/sti_store/commit/cfe3e3c37c3ab981178659a5cf5612f5a0a5d3d3#diff-2ae590dbba6e11e800e7b310da3855da)
the `batting_average` accessor, but `Footballer` and `Player` [do not](https://github.com/velocity-labs/sti_store/commit/cfe3e3c37c3ab981178659a5cf5612f5a0a5d3d3#diff-994c087fa7c1467a491fcbc9769d928e).

At this point we should [add a validation](https://github.com/velocity-labs/sti_store/commit/316696324f4b47ef3e4909434a3161bf884d0726) in the subclass
for our new attribute, and it works with `store_accessor` as expected.

With this approach when we [add the bowler](https://github.com/velocity-labs/sti_store/commit/fb95ff07e39aeb340500b792e3415aae3b8c3bf0#diff-7ec343fa48e70334670e2a9104c75c9a)
we just need to specify its `bowling_average` attribute in another `store_accessor`.
Note that the `Bowler` model inherits its parent's `batting_average` attribute, as [shown here](https://github.com/velocity-labs/sti_store/commit/fb95ff07e39aeb340500b792e3415aae3b8c3bf0#diff-3b15f39dcd54b7cced69d2d5629fe4f4).

Looking at this in [`psql`](http://www.postgresql.org/docs/9.4/static/app-psql.html) we now see the single `sti_store` column, showing only the appropriate values for each `type`:

    sti_store_development=# SELECT name, type, sti_store FROM players;
     name  |    type    |                    sti_store
    -------+------------+-------------------------------------------------
     Alice | Footballer |
     Bob   | Cricketer  | {"batting_average":61.2}
     Carol | Bowler     | {"batting_average":12.3,"bowling_average":80.3}
    (3 rows)

Much better.

### Errata:

Is PostgreSQL's JSON required?

Not necessarily, we use `store_accessor` directly, but it should be
possible to use `store` instead (see the [`ActiveRecord::Store`](http://api.rubyonrails.org/classes/ActiveRecord/Store.html) documentation).
